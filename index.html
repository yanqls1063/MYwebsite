<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aim Trainer</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33;
      --text:#e8ecff;
      --muted:#a7b0d6;
      --line:rgba(255,255,255,.10);
      --good:#59f3a6;
      --bad:#ff6b6b;
      --accent:#7aa2ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: radial-gradient(1200px 800px at 30% 10%, rgba(122,162,255,.22), transparent 55%),
                  radial-gradient(900px 700px at 80% 30%, rgba(89,243,166,.12), transparent 60%),
                  var(--bg);
      color:var(--text);
    }
    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding:18px;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:16px;
    }
    @media (max-width: 900px){
      .wrap{grid-template-columns: 1fr}
    }
    .card{
      background: rgba(18,26,51,.92);
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow: 0 18px 48px rgba(0,0,0,.35);
      overflow:hidden;
    }
    header{
      padding:16px 16px 8px 16px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
    }
    h1{
      margin:0;
      font-size:20px;
      letter-spacing:.2px;
    }
    .sub{
      margin:6px 0 0 0;
      font-size:12px;
      color:var(--muted);
    }
    .panel{
      padding:14px 16px 16px 16px;
      border-top:1px solid var(--line);
    }
    .row{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin:10px 0;
    }
    label{
      font-size:13px;
      color:var(--muted);
      display:flex;
      flex-direction:column;
      gap:6px;
      flex:1;
    }
    .value{
      font-variant-numeric: tabular-nums;
      font-size:12px;
      color:var(--text);
      opacity:.9;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .select, .checkbox{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.10);
    }
    select{
      width: 160px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:8px 10px;
      outline:none;
    }
    input[type="checkbox"]{
      width:18px; height:18px;
      accent-color: var(--accent);
    }
    .btns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button{
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:600;
      letter-spacing:.2px;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    button:hover{background: rgba(255,255,255,.10)}
    button.primary{
      background: rgba(122,162,255,.18);
      border-color: rgba(122,162,255,.35);
    }
    button.primary:hover{background: rgba(122,162,255,.26)}
    button.danger{
      background: rgba(255,107,107,.12);
      border-color: rgba(255,107,107,.35);
    }
    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:12px;
    }
    .stat{
      padding:12px;
      border:1px solid var(--line);
      border-radius:16px;
      background: rgba(0,0,0,.12);
    }
    .stat .k{font-size:12px; color:var(--muted)}
    .stat .v{
      margin-top:6px;
      font-size:18px;
      font-weight:800;
      font-variant-numeric: tabular-nums;
    }

    /* Arena */
    .arenaWrap{
      padding:14px;
      border-top:1px solid var(--line);
    }
    .arena{
      position:relative;
      width:100%;
      height:auto;
      min-height: 420px;
      background:
        linear-gradient(to bottom, rgba(255,255,255,.06), rgba(255,255,255,0)),
        radial-gradient(1200px 900px at 50% 100%, rgba(0,0,0,.35), transparent 60%),
        rgba(8,12,26,.75);
      border:1px solid var(--line);
      border-radius:18px;
      overflow:hidden;
      user-select:none;

      /* default ratio */
      aspect-ratio: 16 / 9;
    }
    .arena.fullHeight{
      aspect-ratio: auto;
      height: 72vh;
      min-height: 520px;
    }
    .arenaTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      background: rgba(0,0,0,.14);
    }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:8px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      background: rgba(255,255,255,.05);
      white-space:nowrap;
    }
    .pill b{
      color:var(--text);
      font-variant-numeric: tabular-nums;
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      opacity:.9;
    }
    .target{
      position:absolute;
      border-radius:999px;
      transform: translate(-50%,-50%);
      cursor: crosshair;
      box-shadow:
        0 12px 34px rgba(0,0,0,.45),
        0 0 0 2px rgba(255,255,255,.10) inset;
      background:
        radial-gradient(circle at 50% 50%, rgba(255,255,255,.95) 0 18%, rgba(255,255,255,.2) 19% 22%, transparent 23%),
        radial-gradient(circle at 50% 50%, rgba(122,162,255,.85) 0 42%, rgba(122,162,255,.35) 43% 60%, rgba(255,255,255,.06) 61% 100%);
    }
    .flash{
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity:0;
      transition: opacity .08s;
    }
    .flash.good{background: rgba(89,243,166,.08)}
    .flash.bad{background: rgba(255,107,107,.08)}
    .flash.show{opacity:1}
    .overlay{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:10px;
      background: rgba(0,0,0,.25);
      text-align:center;
      padding:24px;
    }
    .overlay h2{
      margin:0;
      font-size:22px;
      letter-spacing:.2px;
    }
    .overlay p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      max-width: 520px;
      line-height:1.5;
    }
    .kbd{
      padding:2px 8px;
      border:1px solid var(--line);
      border-radius:8px;
      background: rgba(255,255,255,.06);
      color:var(--text);
      font-variant-numeric: tabular-nums;
      font-size:12px;
    }

    /* Fullscreen polish */
    .arena:fullscreen{
      border-radius: 0;
      border: none;
      width: 100vw;
      height: 100vh;
      aspect-ratio: auto;
      background:
        radial-gradient(1200px 900px at 50% 100%, rgba(0,0,0,.35), transparent 60%),
        rgba(8,12,26,.92);
    }
    .arena:fullscreen .arenaTop{
      border-radius:0;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <section class="card">
      <header>
        <div>
          <h1>Aim Trainer</h1>
          <p class="sub">사운드 · 화면비율 · 전체화면 · 동시타겟 · 무제한 유지시간</p>
        </div>
        <div class="pill" title="페이지가 업데이트 안 되면 Ctrl+F5">버전 <b>1.1</b></div>
      </header>

      <div class="panel">
        <div class="row">
          <label>
            제한 시간 <span class="value" id="vDuration"></span>
            <input id="duration" type="range" min="10" max="180" step="5" value="30" />
          </label>
        </div>

        <div class="row">
          <label>
            타겟 크기 <span class="value" id="vSize"></span>
            <input id="size" type="range" min="16" max="90" step="2" value="42" />
          </label>
        </div>

        <div class="row">
          <label>
            등장 간격(리젠 속도) <span class="value" id="vInterval"></span>
            <input id="interval" type="range" min="200" max="2500" step="50" value="700" />
          </label>
        </div>

        <div class="row">
          <label>
            타겟 유지 시간 <span class="value" id="vLife"></span>
            <input id="life" type="range" min="300" max="4000" step="50" value="1200" />
          </label>
        </div>

        <div class="row">
          <label>
            동시 타겟 개수 <span class="value" id="vCount"></span>
            <input id="count" type="range" min="1" max="10" step="1" value="1" />
          </label>
        </div>

        <div class="select" style="margin-top:10px;">
          <div style="display:flex;flex-direction:column;gap:4px;">
            <div style="font-size:13px;color:var(--muted);">화면 비율</div>
            <div class="value">아레나(게임 화면) 크기/비율</div>
          </div>
          <select id="ratio">
            <option value="16:9" selected>16:9</option>
            <option value="4:3">4:3</option>
            <option value="1:1">1:1</option>
            <option value="full">세로 크게(뷰 높이)</option>
          </select>
        </div>

        <div class="checkbox" style="margin-top:10px;">
          <div style="display:flex;flex-direction:column;gap:4px;">
            <div style="font-size:13px;color:var(--muted);">타겟 유지시간 무제한</div>
            <div class="value">켜면 타겟이 사라지지 않고, “맞추면” 다음 타겟이 나옵니다</div>
          </div>
          <input id="unlimitedLife" type="checkbox" />
        </div>

        <div class="checkbox" style="margin-top:10px;">
          <div style="display:flex;flex-direction:column;gap:4px;">
            <div style="font-size:13px;color:var(--muted);">사운드</div>
            <div class="value">명중/미스 효과음</div>
          </div>
          <input id="soundOn" type="checkbox" checked />
        </div>

        <div class="row">
          <label>
            사운드 볼륨 <span class="value" id="vVol"></span>
            <input id="volume" type="range" min="0" max="100" step="1" value="35" />
          </label>
        </div>

        <div class="btns">
          <button class="primary" id="startBtn">시작</button>
          <button id="pauseBtn">일시정지</button>
          <button class="danger" id="resetBtn">리셋</button>
        </div>

        <div class="stats">
          <div class="stat"><div class="k">점수</div><div class="v" id="score">0</div></div>
          <div class="stat"><div class="k">남은 시간</div><div class="v" id="time">0.0s</div></div>
          <div class="stat"><div class="k">정확도</div><div class="v" id="acc">0%</div></div>
          <div class="stat"><div class="k">평균 반응속도</div><div class="v" id="rt">-</div></div>
          <div class="stat"><div class="k">명중</div><div class="v" id="hits">0</div></div>
          <div class="stat"><div class="k">미스</div><div class="v" id="miss">0</div></div>
        </div>

        <p class="sub" style="margin-top:12px; line-height:1.5">
          단축키: <span class="kbd">Space</span> 시작/일시정지 · <span class="kbd">R</span> 리셋 · <span class="kbd">F</span> 전체화면
        </p>
      </div>
    </section>

    <section class="card">
      <div class="arenaTop">
        <div class="pill">상태: <b id="state">대기</b></div>
        <div style="display:flex; gap:10px; align-items:center;">
          <div class="hint">타겟 클릭 = 명중 · 빈 곳 클릭 = 미스</div>
          <button id="fsBtn" title="전체화면 (F)">전체화면</button>
        </div>
      </div>

      <div class="arenaWrap">
        <div class="arena" id="arena">
          <div class="flash good" id="flashGood"></div>
          <div class="flash bad" id="flashBad"></div>

          <div class="overlay" id="overlay">
            <h2>에임 연습장</h2>
            <p>
              왼쪽에서 설정을 조절하고 <b>시작</b>을 누르세요.<br>
              목표: 제한 시간 동안 최대한 많이, 정확하게 맞추기.
            </p>
            <p class="sub">추천: 동시 타겟 3~5로 올리면 추적 난이도 확 올라가!</p>
          </div>
        </div>
      </div>
    </section>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // Inputs
  const durationEl = $("duration");
  const sizeEl = $("size");
  const intervalEl = $("interval");
  const lifeEl = $("life");
  const countEl = $("count");
  const ratioEl = $("ratio");
  const unlimitedLifeEl = $("unlimitedLife");
  const soundOnEl = $("soundOn");
  const volumeEl = $("volume");

  // Labels
  const vDuration = $("vDuration");
  const vSize = $("vSize");
  const vInterval = $("vInterval");
  const vLife = $("vLife");
  const vCount = $("vCount");
  const vVol = $("vVol");

  // Buttons
  const startBtn = $("startBtn");
  const pauseBtn = $("pauseBtn");
  const resetBtn = $("resetBtn");
  const fsBtn = $("fsBtn");

  // Arena
  const arena = $("arena");
  const overlay = $("overlay");
  const flashGood = $("flashGood");
  const flashBad = $("flashBad");

  // Stats
  const stateEl = $("state");
  const scoreEl = $("score");
  const timeEl = $("time");
  const accEl = $("acc");
  const rtEl = $("rt");
  const hitsEl = $("hits");
  const missEl = $("miss");

  // -------------------------
  // Sound (Web Audio)
  // -------------------------
  let audioCtx = null;

  function ensureAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === "suspended"){
      audioCtx.resume().catch(()=>{});
    }
  }

  function playTone({freq=440, duration=0.06, type="sine", gain=0.08, ramp=0.015}){
    if (!soundOnEl.checked) return;
    ensureAudio();

    const vol = Number(volumeEl.value) / 100;
    const g = audioCtx.createGain();
    const o = audioCtx.createOscillator();

    o.type = type;
    o.frequency.value = freq;

    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0001, gain * vol), now + ramp);
    g.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    o.connect(g);
    g.connect(audioCtx.destination);

    o.start(now);
    o.stop(now + duration + 0.01);
  }

  function sfxHit(){
    // crisp "tick"
    playTone({freq: 880, duration: 0.05, type: "square", gain: 0.06, ramp: 0.01});
    playTone({freq: 1320, duration: 0.04, type: "sine", gain: 0.04, ramp: 0.01});
  }
  function sfxMiss(){
    // low "thud"
    playTone({freq: 180, duration: 0.08, type: "triangle", gain: 0.08, ramp: 0.01});
  }

  // -------------------------
  // Game state
  // -------------------------
  let running = false;
  let ended = false;

  let score = 0;
  let hits = 0;
  let miss = 0;
  let shots = 0;

  let reactionTimes = [];

  // timers
  let tickTimer = null;
  let spawnTimer = null;     // used in normal mode for respawn rhythm
  let lifeTimers = new Map();// per-target timers in normal mode
  let tLeftMs = 0;
  let startedAtPerf = 0;

  // targets
  // Map<HTMLElement, bornAtMs>
  let targets = new Map();

  function fmtMs(ms){ return Math.round(ms) + "ms"; }
  function fmtPct(x){ return Math.round(x) + "%"; }
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function updateLabels(){
    vDuration.textContent = `${durationEl.value}s`;
    vSize.textContent = `${sizeEl.value}px`;
    vInterval.textContent = `${intervalEl.value}ms`;
    vLife.textContent = unlimitedLifeEl.checked ? `무제한` : `${lifeEl.value}ms`;
    vCount.textContent = `${countEl.value}개`;
    vVol.textContent = `${volumeEl.value}%`;
  }

  function setState(text){ stateEl.textContent = text; }

  function updateStats(){
    scoreEl.textContent = score;
    hitsEl.textContent = hits;
    missEl.textContent = miss;

    const acc = shots === 0 ? 0 : (hits / shots) * 100;
    accEl.textContent = fmtPct(acc);

    if (reactionTimes.length === 0){
      rtEl.textContent = "-";
    } else {
      const avg = reactionTimes.reduce((a,b)=>a+b,0) / reactionTimes.length;
      rtEl.textContent = fmtMs(avg);
    }
  }

  function showFlash(kind){
    const el = kind === "good" ? flashGood : flashBad;
    el.classList.add("show");
    setTimeout(() => el.classList.remove("show"), 90);
  }

  function clearTimers(){
    if (tickTimer) clearInterval(tickTimer);
    if (spawnTimer) clearInterval(spawnTimer);
    tickTimer = spawnTimer = null;

    for (const [,tid] of lifeTimers){
      clearTimeout(tid);
    }
    lifeTimers.clear();
  }

  function removeAllTargets(){
    for (const [el] of targets){
      el.remove();
    }
    targets.clear();

    for (const [,tid] of lifeTimers){
      clearTimeout(tid);
    }
    lifeTimers.clear();
  }

  function applyRatio(){
    const v = ratioEl.value;
    arena.classList.remove("fullHeight");
    if (v === "full"){
      arena.classList.add("fullHeight");
      return;
    }
    if (v === "16:9") arena.style.aspectRatio = "16 / 9";
    if (v === "4:3") arena.style.aspectRatio = "4 / 3";
    if (v === "1:1") arena.style.aspectRatio = "1 / 1";
  }

  function spawnOneTarget(){
    const size = Number(sizeEl.value);
    const rect = arena.getBoundingClientRect();

    // Keep within bounds
    const pad = size * 0.65;
    const x = clamp(Math.random() * rect.width, pad, rect.width - pad);
    const y = clamp(Math.random() * rect.height, pad, rect.height - pad);

    const t = document.createElement("div");
    t.className = "target";
    t.style.width = size + "px";
    t.style.height = size + "px";
    t.style.left = x + "px";
    t.style.top = y + "px";

    const bornAt = performance.now();
    targets.set(t, bornAt);

    t.addEventListener("click", (e) => {
      e.stopPropagation();
      if (!running || ended) return;

      const born = targets.get(t) ?? performance.now();
      const rt = performance.now() - born;
      reactionTimes.push(rt);

      hits++;
      shots++;
      score++;

      sfxHit();
      showFlash("good");
      updateStats();

      // remove current target
      t.remove();
      targets.delete(t);

      // clear life timer for this target if exists
      const tid = lifeTimers.get(t);
      if (tid) clearTimeout(tid);
      lifeTimers.delete(t);

      // In unlimited life mode: only spawn on hit to maintain count
      // In normal mode: also maintain count immediately (snappy feel)
      maintainTargetCount(true);
    });

    arena.appendChild(t);

    // normal mode: auto-respawn after life
    if (!unlimitedLifeEl.checked){
      const tid = setTimeout(() => {
        if (!running || ended) return;
        if (!targets.has(t)) return;

        // target "expired" -> respawn (no shot counted)
        t.remove();
        targets.delete(t);
        lifeTimers.delete(t);

        maintainTargetCount(false);
      }, Number(lifeEl.value));

      lifeTimers.set(t, tid);
    }
  }

  function maintainTargetCount(onHit){
    const desired = Number(countEl.value);

    // Unlimited mode rule: next target appears when you hit (and to fill missing ones initially).
    // So if unlimitedLife is ON and this call isn't from a hit, we only fill when starting/initializing.
    if (unlimitedLifeEl.checked && !onHit){
      // fill only if currently below desired (e.g. start/reset) -> allowed
      while (targets.size < desired) spawnOneTarget();
      return;
    }

    // Normal mode: fill to desired anytime; Unlimited+onHit: fill to desired upon hit
    while (targets.size < desired) spawnOneTarget();

    // If user lowered count mid-game, trim extras
    if (targets.size > desired){
      let removeN = targets.size - desired;
      for (const [el] of targets){
        if (removeN <= 0) break;
        el.remove();
        targets.delete(el);
        const tid = lifeTimers.get(el);
        if (tid) clearTimeout(tid);
        lifeTimers.delete(el);
        removeN--;
      }
    }
  }

  function startGame(){
    // unlocking audio on user gesture
    if (soundOnEl.checked) ensureAudio();

    if (running) return;
    if (ended) resetGame();

    running = true;
    ended = false;
    overlay.style.display = "none";
    setState("진행 중");

    tLeftMs = Number(durationEl.value) * 1000;
    startedAtPerf = performance.now();

    // time tick
    tickTimer = setInterval(() => {
      const elapsed = performance.now() - startedAtPerf;
      const remain = Math.max(0, tLeftMs - elapsed);
      timeEl.textContent = (remain/1000).toFixed(1) + "s";
      if (remain <= 0) endGame();
    }, 50);

    // Spawn logic
    removeAllTargets();
    maintainTargetCount(false);

    // Normal mode has interval-based "refresh rhythm"
    if (!unlimitedLifeEl.checked){
      spawnTimer = setInterval(() => {
        if (!running || ended) return;
        // Instead of nuking everything, we gently ensure count and also "refresh" by expiring one occasionally
        // Simple approach: if many targets, refresh 1 per tick
        if (targets.size > 0){
          const first = targets.keys().next().value;
          if (first){
            // expire one (no shot)
            first.remove();
            targets.delete(first);
            const tid = lifeTimers.get(first);
            if (tid) clearTimeout(tid);
            lifeTimers.delete(first);
          }
        }
        maintainTargetCount(false);
      }, Number(intervalEl.value));
    }
  }

  function pauseGame(){
    if (!running) return;
    running = false;
    setState("일시정지");
    overlay.style.display = "flex";
    overlay.querySelector("h2").textContent = "일시정지";
    overlay.querySelector("p").innerHTML = `계속하려면 <b>시작</b>을 누르거나 <span class="kbd">Space</span>를 누르세요.`;

    clearTimers();
    removeAllTargets();
  }

  function endGame(){
    ended = true;
    running = false;

    clearTimers();
    removeAllTargets();

    setState("종료");
    overlay.style.display = "flex";
    overlay.querySelector("h2").textContent = "결과";

    const acc = shots === 0 ? 0 : (hits / shots) * 100;
    const avg = reactionTimes.length ? (reactionTimes.reduce((a,b)=>a+b,0)/reactionTimes.length) : 0;

    overlay.querySelector("p").innerHTML =
      `점수 <b>${score}</b> · 정확도 <b>${Math.round(acc)}%</b> · 평균 반응속도 <b>${reactionTimes.length ? Math.round(avg)+"ms" : "-"}</b><br>
       다시 하려면 <b>시작</b> 또는 <span class="kbd">R</span>.`;

    timeEl.textContent = "0.0s";
  }

  function resetGame(){
    clearTimers();
    removeAllTargets();

    running = false;
    ended = false;

    score = 0;
    hits = 0;
    miss = 0;
    shots = 0;
    reactionTimes = [];

    updateStats();
    setState("대기");
    timeEl.textContent = Number(durationEl.value).toFixed(1) + "s";

    overlay.style.display = "flex";
    overlay.querySelector("h2").textContent = "에임 연습장";
    overlay.querySelector("p").innerHTML =
      `왼쪽에서 설정을 조절하고 <b>시작</b>을 누르세요.<br>목표: 제한 시간 동안 최대한 많이, 정확하게 맞추기.`;

    applyRatio();
  }

  // Miss clicks: clicking arena but not target
  arena.addEventListener("click", () => {
    if (!running || ended) return;
    shots++;
    miss++;
    sfxMiss();
    showFlash("bad");
    updateStats();
  });

  // Fullscreen
  async function toggleFullscreen(){
    try{
      if (!document.fullscreenElement){
        await arena.requestFullscreen();
        fsBtn.textContent = "전체화면 해제";
      } else {
        await document.exitFullscreen();
        fsBtn.textContent = "전체화면";
      }
    } catch(e){
      // ignore
    }
  }

  document.addEventListener("fullscreenchange", () => {
    fsBtn.textContent = document.fullscreenElement ? "전체화면 해제" : "전체화면";
  });

  // Controls
  startBtn.addEventListener("click", startGame);
  pauseBtn.addEventListener("click", pauseGame);
  resetBtn.addEventListener("click", resetGame);
  fsBtn.addEventListener("click", toggleFullscreen);

  function onSettingChange(){
    updateLabels();
    applyRatio();

    // If unlimited is on, life slider isn't used
    lifeEl.disabled = unlimitedLifeEl.checked;
    intervalEl.disabled = unlimitedLifeEl.checked; // 무제한 모드에서는 “맞추면 다음 타겟”이 핵심이라 간격 비활성화

    if (running && !ended){
      // Restart spawn behavior safely (keep score/time running)
      clearTimers();
      // keep remaining time by adjusting startedAtPerf so remain doesn't jump:
      const elapsed = performance.now() - startedAtPerf;
      const remain = Math.max(0, tLeftMs - elapsed);
      // restart tick with same remain
      tLeftMs = remain;
      startedAtPerf = performance.now();

      tickTimer = setInterval(() => {
        const elapsed2 = performance.now() - startedAtPerf;
        const remain2 = Math.max(0, tLeftMs - elapsed2);
        timeEl.textContent = (remain2/1000).toFixed(1) + "s";
        if (remain2 <= 0) endGame();
      }, 50);

      // Rebuild targets to fit new size/count/mode cleanly
      removeAllTargets();
      maintainTargetCount(false);

      if (!unlimitedLifeEl.checked){
        spawnTimer = setInterval(() => {
          if (!running || ended) return;
          if (targets.size > 0){
            const first = targets.keys().next().value;
            if (first){
              first.remove();
              targets.delete(first);
              const tid = lifeTimers.get(first);
              if (tid) clearTimeout(tid);
              lifeTimers.delete(first);
            }
          }
          maintainTargetCount(false);
        }, Number(intervalEl.value));
      }
    } else {
      timeEl.textContent = Number(durationEl.value).toFixed(1) + "s";
    }
  }

  [durationEl, sizeEl, intervalEl, lifeEl, countEl, ratioEl, unlimitedLifeEl, soundOnEl, volumeEl]
    .forEach(el => el.addEventListener("input", onSettingChange));

  // Hotkeys
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space"){
      e.preventDefault();
      if (running) pauseGame();
      else startGame();
    }
    if (e.key.toLowerCase() === "r"){
      resetGame();
    }
    if (e.key.toLowerCase() === "f"){
      toggleFullscreen();
    }
  });

  // Init
  updateLabels();
  applyRatio();
  onSettingChange();
  resetGame();
})();
</script>
</body>
</html>
